<p>I was talking with a co-worker today about the behavior of <code class="js inline">setTimeout</code> and <code class="js inline">setInterval</code> when given a small interval, like <code class="js inline">0</code> or <code class="js inline">1</code>.  The <em>expectation</em> would be that the timer will fire in 0ms, or 1ms.  However, as with <a href="http://wtfjs.com" target="_blank">other things</a> in JavaScript, the <em>reality</em> is a bit different.  It turns out that browsers actually have a <strong>minimum timer interval</strong> which they can't work any faster than.  John Resig wrote about <a href="http://ejohn.org/blog/analyzing-timer-performance/" target="_blank">timer performance</a> a few years back, and found this behavior.  He's also covering it in more detail in his new book.</p>
<p>But, I wasn't happy with data a few years old, so I decided to just go and write my own simple test suite, <a href="http://www.bcherry.net/playground/settimeout">How Fast is setTimeout in Your Browser?</a>.  This page simply runs <code class="js inline">setTimeout</code> with an interval of 0, 1000 times, and averages the <em>real</em> timeout experienced in each.  Go ahead and check it out in your browser of choice.</p>
<h2>The Results</h2>
<p>Well, it turns out that things aren't so bad.  Most browsers are in the <strong>10-15ms</strong> range for their bottom limit, having improved in recent versions.  Notable exceptions are Internet Explorer, which has the same bottom of around <strong>16ms</strong> in all versions since IE6, and Google Chrome, which, at least since version 4, has a bottom limit closer to <strong>5ms</strong>  It's important to keep this limitation in mind when using <code class="js inline">setTimeout</code> or <code class="js inline">setInterval</code>.  In particular, if you're looking for consistent timer intervals across browsers, you have to use something <strong>&gt;15ms</strong>.  But, don't forget that JavaScript is single-threaded, and the timer won't execute while other code is executing.  This means that in the following code sample, you can guarantee that the timer <strong>will not run</strong> until the loop has completed.  You cannot, however, guarantee precisely when that will happen, nor that it will be the next piece of code to run following the loop.</p>
<pre class="js">setTimeout(function () { alert("timer"); }, 0);
for (var i = 0; i &lt; 1000; i += 1) {
	// something
}</pre>
<p>So it should be safe to use timers with an interval of 0ms when your only expectation is that the timer will fire as soon as it can, but not until after the current code path has completed.  Relying on timers to respect the interval you give them is foolish, since, as I've shown, they have a lower-bound, and since they wait even after firing, before executing, for other code to return.</p>
<h2>The Source Code</h2>
<p>This test is really simple.  Here's the complete JavaScript source code:</p>
<pre class="js">var target = document.getElementById("target"),
	results = 0,
	iterations = 1000,
	i = 0;

function go() {
	var fn = function () {
			results += new Date().getTime() - d;
			i += 1;
			if (i &lt; iterations) {
				go();
			} else {
				finish();
			}
		},
		d = new Date().getTime();
	setTimeout(fn, 0);
}

function finish() {
	target.innerHTML = "Average timer delay was &lt;span class=\"num\"&gt;" + results/iterations + "&lt;/span&gt;ms, over &lt;span class=\"num\"&gt;" + iterations + "&lt;/span&gt; iterations.";
}

go();</pre>
<p>And that's all there is to it.  I hope you found this interesting :)</p>