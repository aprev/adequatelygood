<p>One particular weirdness and unpleasantry in JavaScript is the set of equality operators.  Like virtually every language, JavaScript has the standard <code class="js inline">==</code>, <code class="js inline">!=</code>, <code class="js inline">&lt;</code>, <code class="js inline">&gt;</code>, <code class="js inline">&lt;=</code>, and <code class="js inline">&gt;=</code> operators.  However, <code class="js inline">==</code> and <code class="js inline">!=</code> are NOT the operators most would think they are.  These operators do <strong>type coercion</strong>, which is why <code class="js inline">[0] == 0</code> and <code class="js inline">"\n0\t " == 0</code> both evaluate to <code class="js inline">true</code>.  This is considered, by sane people, to be a <strong>bad thing</strong>.  Luckily, JavaScript does provide a normal set of equality operators, which do what you expect: <code class="js inline">===</code> and <code class="js inline">!===</code>.  It sucks that we need these at all, and <code class="js inline">===</code> is a pain to type, but at least <code class="js inline">[0] !== 0</code>.</p>
<p>So, that's all well and good, but when making the decision to use <code class="js inline">===</code> instead of <code class="js inline">==</code> it's important to understand if there are any performance implications.  Reasonable people, like myself, would expect the strict equality operators to be faster than their type-coercing counterparts, because the type coercion must take time.  But, being <a href="http://xkcd.com/242/" target="_blank">a scientist</a>, I had to set up an experiment to test this hypothesis.</p>
<h2>For Science!</h2>
<p><a href="http://www.bcherry.net/playground/comparisons">My experiment</a> times the execution time of 24 different tests, in the browser you view it in.  These tests represent every permutation of the following factors:</p>
<ol>
	<li><strong>Use</strong>: Whether the result is computed and thrown away, or assigned into a local variable.</li>
	<li><strong>Comparison</strong>: Comparing integers vs. integers, strings vs. strings, and integers vs. strings.</li>
	<li><strong>Operands</strong>: Whether the operands are actually equal or unequal (with forced type coercion in the case of <code class="js inline">===</code>).</li>
	<li><strong>Operator</strong>: Using either <code class="js inline">==</code> or <code class="js inline">===</code>.</li>
</ol>
<p>Note that I am specifically <strong>not</strong> testing the relative performance when comparing against values like <code class="js inline">null</code>, <code class="js inline">undefined</code>, or <code class="js inline">false</code>.  This is because those are falsy values which have even worse type coercion characteristics.  Some integers and strings can, of course, also be falsy, such as <code class="js inline">0</code> or <code class="js inline">""</code>, but these are normal values which occur during arithmetic or string comparison, so I've tested with them.</p>
<p>The tests were run over two million iterations, except in Internet Explorer, where it produced a long-running script error, so I cut it to 500,000 iterations.  Here are the browser configurations I tested:</p>
<ol>
	<li>Mozilla Firefox 3.6 (Mac)</li>
	<li>Google Chrome 5 (Mac dev channel)</li>
	<li>Internet Explorer 8 (iterations reduced by 4x)</li>
	<li>Safari 4 (Mac)</li>
	<li>Opera 10.5 beta (Mac)</li>
	<li>Mozilla Firefox 3.6 (Mac) with Firebug open</li>
</ol>
<h2>Results</h2>
<p>My results are <a href="http://spreadsheets.google.com/pub?key=taW8f6kvj3kUVObtg4p9vqQ&amp;output=html" target="_blank">available as a Google spreadsheet here</a>.  It turns out that there is little practical performance difference between <code class="js inline">==</code> and <code class="js inline">===</code>.  While the strict operator is marginally faster (roughly 10%) in most browsers when combined with explicit type conversion, such as <code class="js inline">a === +b</code>, the only real performance gains will come from avoiding type conversion entirely.  <strong>Converting a string to an integer for comparison with another integer is significantly slower (up to 10x) than simple comparing two integers</strong>.  You should never allow integers to be stored as strings internally, as the type conversion will incur a performance penalty.</p>
<p>While that was the basic takeaway from the numbers, I did find one interesting outlier when testing with Firefox.  In Firefox, the comparison <code class="js inline">a === +b</code> is about 20x slower than the equivalent <code class="js inline">a == b</code> when <code class="js inline">a</code> is an integer and <code class="js inline">b</code> is a string integer.  This result seems suspicious to me, and nothing similar occurred in any other browser.  Oddly, when the Firebug script debugger is turned on, this result changes, and <code class="js inline">a === +b</code> becomes about 10% faster than the other.  I'm not sure what to make of this result, but it does serve as a reminder that integers should always be stored in numbers, not in strings.</p>
<h2>Conclusion</h2>
<p>Not much surprise in these results, other than the Firefox result.  But, it did help me avoid a nagging worry that I'm silently slowing down my code whenever I use <code class="js inline">===</code> instead of <code class="js inline">==</code> in my JavaScript.</p>
<p>Again, find the test <a href="" target="_blank">here</a> and my results <a href="http://spreadsheets.google.com/pub?key=taW8f6kvj3kUVObtg4p9vqQ&amp;output=html" target="_blank">here</a>.  I hope you found this information interesting.  Let me know in the comments if you see different results than I got.</p>